# Zipkin_Sleuth
![image](https://github.com/Nekipel/Zipkin_Sleuth/assets/88710417/d9c0db6b-6e97-4924-ade1-9f4c31783acc)
В микросервисах мы неизбежно сталкиваемся с большим количеством запросов^ как внешних, так и внутренних между сервисами. В прошлых уроках мы в основном рассматривали механизмы для отказоустойчивости системы. Но как же мониторить и понимать, на каком этапе произошел сбой? 

Для этого существуют различные механизмы трассировки запросов в микросервисной среде, один из них — Sleuth в сочетании с Zipkin.

Sleuth— механизм трассировки.

Zipkin — журнал событий.

Под капотом Sleuth передает информацию в виде:

[application name, traceId, spanId, export]

Давай подробно рассмотрим каждый пункт:

application name — имя приложения.

traceId — ID, назначаемый каждому запросу. 

spanId — используется для отслеживания работы. Каждый запрос может иметь множество шагов, которые будут вызываться по цепочке от одного сервиса к другому. Каждый этот шаг имеет свой уникальный spanId. 

export — это флаг, который указывает, следует ли экспортировать определенный журнал в инструмент агрегирования журналов, такой как Zipkin.

Весь сок состоит не в том, чтобы идентифицировать журналы в пределах одного сервиса, а в том, чтобы отслеживать цепочку запросов между несколькими сервисами. Именно параметр traceId — это то, что позволит нам отслеживать запрос при его переходе от одного сервиса к другому.

Если ты будешь использовать Feign client от Netflix, информация трассировки также будет добавлена ​​к этим запросам. Кроме того, сам Gateway также будет перенаправлять заголовки через прокси в другие сервисы.

В следующих уроках мы будем рассматривать ELK (Elastic Search + Kibana).  В сочетании с Sleuth ты можешь легко выполнять поиск по всем собранным журналам при помощи параметра traceId и видеть, как запрос передается от одного сервиса к другому по цепочке. Ты даже не представляешь, как это удобно!
![image](https://github.com/Nekipel/Zipkin_Sleuth/assets/88710417/2af4c5ce-1afb-4808-975c-deb440cd9eda)
В большей степени теории здесь мало, поэтому предлагаю сразу перейти к практике.

В следующем уроке настроим Sleuth + Zipkin для нашего client-service. 


Как подключить Sleuth


Нам нужно  добавить лишь одну зависимость.

<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>
Также нужно прописать в файле свойства.

Lospring:
 sleuth:
   sampler:
     probability: 2.0
По умолчанию Sleuth устанавливает все диапазоны как неэкспортируемые в Zipkin (четвертый параметр export = false). Чтобы установить export в true, необходимо указать частоту дискретизации, используя свойство.

sampler:
   probability: 2.0


sleuth не работает на 3 буте
теперь его функционал выполняет micrometer
https://springbootlearning.medium.com/using-micrometer-to-trace-your-spring-boot-app-1fe6ff9982ae
+ нужен actuator

  https://www.youtube.com/watch?v=cbQHsNEUs_k



  Добавление Zipkin

Добавим зависимость в проект.

<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-zipkin</artifactId>
</dependency>
Далее поднимем zipkin в докере следующей командой.

docker run -d -p 9411:9411 openzipkin/zipkin

В файле свойств ничего менять не надо, все по умолчанию включено. Для наглядности можно указать следующее.

spring:
 zipkin:
  enabled: true



  Цель: использование Zipkin и Sleuth.

Задание: добавь зависимости и измени файл свойств для следующих сервисов на основе прошлых лекций: client-service / book-service.
Когда мы перейдем по url
http://localhost:9411
мы увидим простой дашборд ZIpkin.

![image](https://github.com/Nekipel/Zipkin_Sleuth/assets/88710417/82e05258-c247-4afe-8c42-b521bd3c4d1f)

Далее запустим client-service, не запуская book-service. С прошлого модуля у тебя должен остаться лог об ошибке при fallback — его и будем искать.

Выполни запрос на /api/books, затем перейди на дашборд Zipkin и нажми RUN QUERY. Ты увидишь следующее.

![image](https://github.com/Nekipel/Zipkin_Sleuth/assets/88710417/fd68b48f-9c60-4494-a2d0-29cda531ec4c)
Далее нажимаем кнопку SHOW и видим всю цепочку операций, красным подчеркнута операция, которая дала сбой. Переходим в нее и видим тот самый лог, что мы писали при fallback.
![image](https://github.com/Nekipel/Zipkin_Sleuth/assets/88710417/3c51dc70-bfac-46c5-ae2e-99087d6f08a1)
![image](https://github.com/Nekipel/Zipkin_Sleuth/assets/88710417/7c7d7119-905b-4057-985c-b4674b7e0a0c)
В моем примере был запущен лишь client-service и eureka. Поиграй с интерфейсом zipkin, посмотри, как будет выглядеть трассировка при успешном запросе на book-service — все просто и удобно.



